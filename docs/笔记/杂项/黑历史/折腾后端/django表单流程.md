# Django 表单处理

头有点疼好晕记忆力好差理一下思路吧

forms.py中创建了一个表单，而没有在Models.py中创建

这个表单和数据模型一样使用。

我们在views.py中写了一个返回render的视图函数，当我们访问127.0.0.1/blog的时候index()视图被调用，他加载相关变量并填入index.html上下文，将其打包成response后返回给前台。前台展示出这个页面。

这个页面包含了一个表单（它并没有相应的表单模型，我们用了最基本的`<form>`标签实现了它。我们在里面填充点东西，点击ok提交Post表单给后端。它生成了一个内部连接/blog/your-name；后台根据这个连接处理请求。最后这个url被定向到get_name()视图上，它处理这个请求并且创造了一个新的表单（这个表单在forms.py中被定义）。这个表单被嵌入到了formTest.html中，它继承自index.html。顺便说一下，这个表单对应的短连接被设定为了最初了127.0.0.1/blog..请开始无线套娃~

所以最终效果会出现，用户看到的页面大体上没有变，但后台其实用到了两个html，不过另一个html继承自基本的index.html。

值得注意的是，render中的模板参数是个字符串。这导致django无法无检查html的名字是否有误。记得检查！

## DRF流程（新知识主要是序列化器）

序列化器很强大，它绑定在一个模型---视图上，可以控制收发的数据范围和内容。在django中我们把视图作为核心处理阵地，而在drf中，核心被转移到了序列化器身上。这是因为，之前的视图层负责的东西（即前端渲染）已经消失了，drf中的视图的工作基本就是在调用序列化器处理数据后再返回结果。

前端给出一个url和一种请求。

后端路由层接收到之后转发给视图。视图处理请求并返回。基本框架是不变的。只不过视图里多了个序列化器，用于接收传输的数据并把它转换成django对象，和打包即将传输的数据。同时，它是和模型绑定的：使用它，可以设置其中哪些数据只允许读前端读取；哪些数据只允许被写入（也就是说，对于用一个模型，在get请求的时候该数据不会被看到，但在post提交请求的时候必须要指定该数据。这可能听起来有些怪，但是确实有这种需求，比如带有标签的文章模型，我们获取一篇文章可能不需要知道其标签id，但是我们在上传新文章的时候可以必须指定其id。）。这种行为通过read_only和write_only控制。

如果请求是post等带有data字段的数据，可能需要在视图层处理一下数据。

容易绕进去的是嵌套序列化器和外键序列化器。他们绑定于模型，配合是否执行列表（many=True），显得很绕。
